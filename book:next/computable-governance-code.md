# Computable Governance Code

Laws and other governance documents are typically written in natural language, which is necessarily vague and imprecise. This is problematic in many ways, since the law is literally just a "code", instructions about governance action that are intended to be as precise as possible. In a very real way, legal codes are just like computer programs, except instead of being executed by computers they are executed by people and institutions. Very often legal codes literally just describe algorithms, step-by-step instructions intended to produce specific defined outcomes. But fuzzy and imprecise natural languages are a very poor fit for this job.

Computer programming languages in contrast are strictly structured, and can be designed so that any specific program always has a single deterministic meaning. This is true because computer programs [are secretly just constructions of pure logic](https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence), so they can have the same absolute precision as pure logic. Building a programming language isn't easy, but it still happens all the time, so building a computable governance language would absolutely be possible. The more interesting question is whether it would improve governance and clarity of the law.

There would be many benefits if we could make our legal codes more like computer languages, as long as we acknowledge the limits of doing so and remain humble about what pure logic can do. Here are some of the benefits we could expect from making governance code "computable":

- We could use [automated proof assistants](https://en.wikipedia.org/wiki/Proof_assistant) to *prove* arbitrary qualities about our laws and legal procedures, such as their consistency with some ethical framework, or that they are provably secure or fair. In the [Magmide project](https://github.com/magmide/magmide) I'm building a proof language capable of being a solid and approachable foundation for all software, and it would be a perfect tool to define any computable governance language. Magmide isn't complete, but we could use existing proof languages just as well.
- We could use *governance* code to extract actual runnable *computer* code to automate aspects of institutional management. This runnable computer code could be used in systems such as government databases, voting machines, form submission websites, etc.
- Computable legal code makes the law more searchable, since a stricter structure allows search algorithms to more easily understand information.
- Legal codes would gain the powers of all programming languages, such as allowing easy reuse of definitions in different parts of the law, easy sharing between groups, and automatic checks that it is sound and addresses all possible conditions.

These benefits would be very cool, but of course there are some obvious possible objections. The rest of this essay will go through some objections and talk about how serious they actually are and whether we could offset them.

## Mainstream Legibility

Many people have brought up the existing social problem of "legalese", the confusing and jargon-filled language that typical laws are written in. It's a fairly serious problem if the laws that govern a group can't actually be understood by most people in that group, and that lack of legibility can unfairly empower a small group of experts since they're the only ones that can successfully navigate and change the law.

Although at first glance it might seem that making governance codes would only make this problem worse, I'm actually convinced it would make it better! Although it's certainly true that there would be groups of experts who did most of the work writing and reasoning about laws, making laws computable can make them more legible for a few reasons:

- A computable governance language has a precise structure, which means it's actually easier to learn! [Open and precise standards tend to make things more fair](https://astralcodexten.substack.com/p/contra-weyl-on-technocracy), since the existence of the standard is something that anyone can reference. If anyone can reference a precise standard, they can either learn from it directly or create even clearer explanations to share with everyone else. As much as programming and programming languages are treated as confusing and opaque magic by many people, it's actually becoming more and more common for people to learn how to program completely by themselves using nothing other than completely free resources. The same would be true for a governance language.
- Governance codes too often use jargon terms, often latin phrases like "per curiam" or "sua sponte" that mean nothing to normal people and that experts only understand because they went through many years of school. These jargon terms are pointless and almost seem to intentionally exclude people based on social or economic status, since they're just a holdover from the era when a high class education always included instruction in latin and greek. When a term like this is used in the law, a reader has to look it up in some external resource, but in a computable language any term can be traced back to its original definition, which at the end of the day has to be written using the basic standard concepts of the language. This makes it possible to truly understand a body of laws without having to understand anything other than the language its written in.
it's just the form that's easy for humans to understand. Instead the computer "parses" the raw text into data structures that the computer understands, and we can display those structures any way we want. For example, in the computer language TypeScript we can write a function that takes in a number and multiplies it by `2` like this: `let double = (n: number) => n * 2`. This probably looks like gibberish if you haven't learned TypeScript, but we could easily write a computer program that would parse that code text and display it like this: "Let's define a function, called `double`, which accepts a `number` we'll call `n`. This function returns the result of multiplying `n` by `2`." You can probably see why computer languages are written to seem like gibberish, since it makes them much shorter and faster to type. But for people trying to read the code, that terseness isn't very helpful. Luckily we can have it both ways!

<!-- governance engineers -->

## Reality isn't Precise

An obvious potential objection to this idea is that the law cannot be fully precise and deterministic since it must interact with the vague and messy natural world, or the inherently subjective decisions and observations of human plaintiffs and investigators. This is absolutely true! But by understanding the difference between *code* and *data*, we can make our legal codes fully deterministic while still acknowledging the messiness they must interact with.



## Social Inertia

The idea of writing governance codes in imprecise natural language is a concept everyone in the world is familiar with, that's been around for thousands of years. There are entire professions centered around the way we write laws and corporate contracts, and these people likely wouldn't be very excited about the entire paradigm of their world changing. And of course, society as a whole is difficult to change, which can be reasonable since it's not always smart to change something that's already working to something we barely understand.

This the biggest problem with this idea, that its risky and expensive and possibly unpopular to make large changes to important aspects of society. Society isn't wrong in being resistant to change, so if we're going to propose some big change we should prove it's a good idea with small-scale experimentation first.

Governments have the power to tax people and enforce laws and go to war, so changing governments is risky and should be done carefully. But changing purely private organizations is a lot less risky, especially if those private organizations are small or new. At some point in the near future, probably after [the Magmide project](https://github.com/magmide/magmide) is fully usable, I intend to build a governance language and to use it to govern private organizations like cooperatives, companies, and political groups. If the idea of computable governance code has been used in enough successful organizations for long enough, then we can more confidently propose using it in governments.

<!-- it would be really cool to have a "(s: Signer) -> Signature<s, T>" type, representing a type that has been proven to be a cryptographic signature of the particular individual signer -->
